(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@ngxs/store'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('@ngxs/logger-plugin', ['exports', '@angular/core', '@ngxs/store', 'rxjs/operators'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.ngxs = global.ngxs || {}, global.ngxs["logger-plugin"] = {}), global.ng.core, global["ngxs-store"], global.rxjs.operators));
})(this, (function (exports, i0, store, operators) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        }
        n["default"] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    var repeat = function (str, times) { return new Array(times + 1).join(str); };
    var pad = function (num, maxLength) { return repeat('0', maxLength - num.toString().length) + num; };
    function formatTime(time) {
        return (pad(time.getHours(), 2) +
            ":" +
            pad(time.getMinutes(), 2) +
            ":" +
            pad(time.getSeconds(), 2) +
            "." +
            pad(time.getMilliseconds(), 3));
    }

    var ActionLogger = /** @class */ (function () {
        function ActionLogger(action, store, logWriter) {
            this.action = action;
            this.store = store;
            this.logWriter = logWriter;
        }
        ActionLogger.prototype.dispatched = function (state) {
            var actionName = store.getActionTypeFromInstance(this.action);
            var formattedTime = formatTime(new Date());
            var message = "action " + actionName + " @ " + formattedTime;
            this.logWriter.startGroup(message);
            // print payload only if at least one property is supplied
            if (this._hasPayload(this.action)) {
                this.logWriter.logGrey('payload', Object.assign({}, this.action));
            }
            this.logWriter.logGrey('prev state', state);
        };
        ActionLogger.prototype.completed = function (nextState) {
            this.logWriter.logGreen('next state', nextState);
            this.logWriter.endGroup();
        };
        ActionLogger.prototype.errored = function (error) {
            this.logWriter.logRedish('next state after error', this.store.snapshot());
            this.logWriter.logRedish('error', error);
            this.logWriter.endGroup();
        };
        ActionLogger.prototype._hasPayload = function (event) {
            var nonEmptyProperties = this._getNonEmptyProperties(event);
            return nonEmptyProperties.length > 0;
        };
        ActionLogger.prototype._getNonEmptyProperties = function (event) {
            var keys = Object.keys(event);
            var values = keys.map(function (key) { return event[key]; });
            return values.filter(function (value) { return value !== undefined; });
        };
        return ActionLogger;
    }());

    var LogWriter = /** @class */ (function () {
        function LogWriter(options) {
            this.options = options;
            this.options = this.options || {};
            this.logger = options.logger || console;
        }
        LogWriter.prototype.startGroup = function (message) {
            var startGroupFn = this.options.collapsed
                ? this.logger.groupCollapsed
                : this.logger.group;
            try {
                startGroupFn.call(this.logger, message);
            }
            catch (e) {
                console.log(message);
            }
        };
        LogWriter.prototype.endGroup = function () {
            try {
                this.logger.groupEnd();
            }
            catch (e) {
                this.logger.log('—— log end ——');
            }
        };
        LogWriter.prototype.logGrey = function (title, payload) {
            var greyStyle = 'color: #9E9E9E; font-weight: bold';
            this.log(title, greyStyle, payload);
        };
        LogWriter.prototype.logGreen = function (title, payload) {
            var greenStyle = 'color: #4CAF50; font-weight: bold';
            this.log(title, greenStyle, payload);
        };
        LogWriter.prototype.logRedish = function (title, payload) {
            var redishStyle = 'color: #FD8182; font-weight: bold';
            this.log(title, redishStyle, payload);
        };
        LogWriter.prototype.log = function (title, color, payload) {
            if (this.isIE()) {
                this.logger.log(title, payload);
            }
            else {
                this.logger.log('%c ' + title, color, payload);
            }
        };
        LogWriter.prototype.isIE = function () {
            var ua = typeof window !== 'undefined' && window.navigator.userAgent
                ? window.navigator.userAgent
                : '';
            var msIE = false;
            var oldIE = ua.indexOf('MSIE ');
            var newIE = ua.indexOf('Trident/');
            if (oldIE > -1 || newIE > -1) {
                msIE = true;
            }
            return msIE;
        };
        return LogWriter;
    }());

    var NGXS_LOGGER_PLUGIN_OPTIONS = new i0.InjectionToken('NGXS_LOGGER_PLUGIN_OPTIONS');

    var NgxsLoggerPlugin = /** @class */ (function () {
        function NgxsLoggerPlugin(_options, _injector) {
            this._options = _options;
            this._injector = _injector;
        }
        NgxsLoggerPlugin.prototype.handle = function (state, event, next) {
            if (this._options.disabled || !this._options.filter(event, state)) {
                return next(state, event);
            }
            this._logWriter = this._logWriter || new LogWriter(this._options);
            // Retrieve lazily to avoid cyclic dependency exception
            this._store = this._store || this._injector.get(store.Store);
            var actionLogger = new ActionLogger(event, this._store, this._logWriter);
            actionLogger.dispatched(state);
            return next(state, event).pipe(operators.tap(function (nextState) {
                actionLogger.completed(nextState);
            }), operators.catchError(function (error) {
                actionLogger.errored(error);
                throw error;
            }));
        };
        return NgxsLoggerPlugin;
    }());
    /** @nocollapse */ NgxsLoggerPlugin.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsLoggerPlugin, deps: [{ token: NGXS_LOGGER_PLUGIN_OPTIONS }, { token: i0__namespace.Injector }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    /** @nocollapse */ NgxsLoggerPlugin.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsLoggerPlugin });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsLoggerPlugin, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [NGXS_LOGGER_PLUGIN_OPTIONS]
                        }] }, { type: i0__namespace.Injector }];
        } });

    var USER_OPTIONS = new i0.InjectionToken('LOGGER_USER_OPTIONS');
    function loggerOptionsFactory(options) {
        var defaultLoggerOptions = {
            logger: console,
            collapsed: false,
            disabled: false,
            filter: function () { return true; }
        };
        return Object.assign(Object.assign({}, defaultLoggerOptions), options);
    }
    var NgxsLoggerPluginModule = /** @class */ (function () {
        function NgxsLoggerPluginModule() {
        }
        NgxsLoggerPluginModule.forRoot = function (options) {
            return {
                ngModule: NgxsLoggerPluginModule,
                providers: [
                    {
                        provide: store.NGXS_PLUGINS,
                        useClass: NgxsLoggerPlugin,
                        multi: true
                    },
                    {
                        provide: USER_OPTIONS,
                        useValue: options
                    },
                    {
                        provide: NGXS_LOGGER_PLUGIN_OPTIONS,
                        useFactory: loggerOptionsFactory,
                        deps: [USER_OPTIONS]
                    }
                ]
            };
        };
        return NgxsLoggerPluginModule;
    }());
    /** @nocollapse */ NgxsLoggerPluginModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsLoggerPluginModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    /** @nocollapse */ NgxsLoggerPluginModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsLoggerPluginModule });
    /** @nocollapse */ NgxsLoggerPluginModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsLoggerPluginModule });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0__namespace, type: NgxsLoggerPluginModule, decorators: [{
                type: i0.NgModule
            }] });

    /**
     * The public api for consumers of @ngxs/logger-plugin
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NGXS_LOGGER_PLUGIN_OPTIONS = NGXS_LOGGER_PLUGIN_OPTIONS;
    exports.NgxsLoggerPlugin = NgxsLoggerPlugin;
    exports.NgxsLoggerPluginModule = NgxsLoggerPluginModule;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ngxs-logger-plugin.umd.js.map
