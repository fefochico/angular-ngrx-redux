import { Inject, Injectable, Injector } from '@angular/core';
import { Store } from '@ngxs/store';
import { catchError, tap } from 'rxjs/operators';
import { ActionLogger } from './action-logger';
import { LogWriter } from './log-writer';
import { NGXS_LOGGER_PLUGIN_OPTIONS } from './symbols';
import * as i0 from "@angular/core";
export class NgxsLoggerPlugin {
    constructor(_options, _injector) {
        this._options = _options;
        this._injector = _injector;
    }
    handle(state, event, next) {
        if (this._options.disabled || !this._options.filter(event, state)) {
            return next(state, event);
        }
        this._logWriter = this._logWriter || new LogWriter(this._options);
        // Retrieve lazily to avoid cyclic dependency exception
        this._store = this._store || this._injector.get(Store);
        const actionLogger = new ActionLogger(event, this._store, this._logWriter);
        actionLogger.dispatched(state);
        return next(state, event).pipe(tap(nextState => {
            actionLogger.completed(nextState);
        }), catchError(error => {
            actionLogger.errored(error);
            throw error;
        }));
    }
}
/** @nocollapse */ NgxsLoggerPlugin.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsLoggerPlugin, deps: [{ token: NGXS_LOGGER_PLUGIN_OPTIONS }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ NgxsLoggerPlugin.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsLoggerPlugin });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.2.17", ngImport: i0, type: NgxsLoggerPlugin, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [NGXS_LOGGER_PLUGIN_OPTIONS]
                }] }, { type: i0.Injector }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9nZ2VyLnBsdWdpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3BhY2thZ2VzL2xvZ2dlci1wbHVnaW4vc3JjL2xvZ2dlci5wbHVnaW4udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdELE9BQU8sRUFBZ0MsS0FBSyxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQ2xFLE9BQU8sRUFBRSxVQUFVLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDakQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDekMsT0FBTyxFQUEyQiwwQkFBMEIsRUFBRSxNQUFNLFdBQVcsQ0FBQzs7QUFHaEYsTUFBTSxPQUFPLGdCQUFnQjtJQUkzQixZQUM4QyxRQUFpQyxFQUNyRSxTQUFtQjtRQURpQixhQUFRLEdBQVIsUUFBUSxDQUF5QjtRQUNyRSxjQUFTLEdBQVQsU0FBUyxDQUFVO0lBQzFCLENBQUM7SUFFSixNQUFNLENBQUMsS0FBVSxFQUFFLEtBQVUsRUFBRSxJQUFzQjtRQUNuRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFPLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxFQUFFO1lBQ2xFLE9BQU8sSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztTQUMzQjtRQUVELElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDbEUsdURBQXVEO1FBQ3ZELElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBUSxLQUFLLENBQUMsQ0FBQztRQUU5RCxNQUFNLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7UUFFM0UsWUFBWSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUUvQixPQUFPLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUM1QixHQUFHLENBQUMsU0FBUyxDQUFDLEVBQUU7WUFDZCxZQUFZLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3BDLENBQUMsQ0FBQyxFQUNGLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNqQixZQUFZLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzVCLE1BQU0sS0FBSyxDQUFDO1FBQ2QsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7O2lJQS9CVSxnQkFBZ0Isa0JBS2pCLDBCQUEwQjtxSUFMekIsZ0JBQWdCOzRGQUFoQixnQkFBZ0I7a0JBRDVCLFVBQVU7OzBCQU1OLE1BQU07MkJBQUMsMEJBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3RvciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTmd4c05leHRQbHVnaW5GbiwgTmd4c1BsdWdpbiwgU3RvcmUgfSBmcm9tICdAbmd4cy9zdG9yZSc7XG5pbXBvcnQgeyBjYXRjaEVycm9yLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBBY3Rpb25Mb2dnZXIgfSBmcm9tICcuL2FjdGlvbi1sb2dnZXInO1xuaW1wb3J0IHsgTG9nV3JpdGVyIH0gZnJvbSAnLi9sb2ctd3JpdGVyJztcbmltcG9ydCB7IE5neHNMb2dnZXJQbHVnaW5PcHRpb25zLCBOR1hTX0xPR0dFUl9QTFVHSU5fT1BUSU9OUyB9IGZyb20gJy4vc3ltYm9scyc7XG5cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOZ3hzTG9nZ2VyUGx1Z2luIGltcGxlbWVudHMgTmd4c1BsdWdpbiB7XG4gIHByaXZhdGUgX3N0b3JlOiBTdG9yZTtcbiAgcHJpdmF0ZSBfbG9nV3JpdGVyOiBMb2dXcml0ZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChOR1hTX0xPR0dFUl9QTFVHSU5fT1BUSU9OUykgcHJpdmF0ZSBfb3B0aW9uczogTmd4c0xvZ2dlclBsdWdpbk9wdGlvbnMsXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yXG4gICkge31cblxuICBoYW5kbGUoc3RhdGU6IGFueSwgZXZlbnQ6IGFueSwgbmV4dDogTmd4c05leHRQbHVnaW5Gbikge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmRpc2FibGVkIHx8ICF0aGlzLl9vcHRpb25zLmZpbHRlciEoZXZlbnQsIHN0YXRlKSkge1xuICAgICAgcmV0dXJuIG5leHQoc3RhdGUsIGV2ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2dXcml0ZXIgPSB0aGlzLl9sb2dXcml0ZXIgfHwgbmV3IExvZ1dyaXRlcih0aGlzLl9vcHRpb25zKTtcbiAgICAvLyBSZXRyaWV2ZSBsYXppbHkgdG8gYXZvaWQgY3ljbGljIGRlcGVuZGVuY3kgZXhjZXB0aW9uXG4gICAgdGhpcy5fc3RvcmUgPSB0aGlzLl9zdG9yZSB8fCB0aGlzLl9pbmplY3Rvci5nZXQ8U3RvcmU+KFN0b3JlKTtcblxuICAgIGNvbnN0IGFjdGlvbkxvZ2dlciA9IG5ldyBBY3Rpb25Mb2dnZXIoZXZlbnQsIHRoaXMuX3N0b3JlLCB0aGlzLl9sb2dXcml0ZXIpO1xuXG4gICAgYWN0aW9uTG9nZ2VyLmRpc3BhdGNoZWQoc3RhdGUpO1xuXG4gICAgcmV0dXJuIG5leHQoc3RhdGUsIGV2ZW50KS5waXBlKFxuICAgICAgdGFwKG5leHRTdGF0ZSA9PiB7XG4gICAgICAgIGFjdGlvbkxvZ2dlci5jb21wbGV0ZWQobmV4dFN0YXRlKTtcbiAgICAgIH0pLFxuICAgICAgY2F0Y2hFcnJvcihlcnJvciA9PiB7XG4gICAgICAgIGFjdGlvbkxvZ2dlci5lcnJvcmVkKGVycm9yKTtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9KVxuICAgICk7XG4gIH1cbn1cbiJdfQ==